# the default values for the data used in the input file
# generation for the unconfined fortran program

# data for model (variables defined as defaults below)
d = {}

f = []

d['infname'] = 'input.dat' # input file read by fortran code

# row 1 
d['quiet'] = False  # echo verbosely to screen while running?
d['model'] = 1      # model to use (0-6)
d['dimless'] = True # dimensionless output?
d['tseries'] = True # timeseries (hydrograph)?  (false -> contour map)
d['piezo'] = True   # point piezometer? (false -> screened observation well)
f.append([d['quiet'],d['model'],d['dimless'],d['tseries'],d['piezo']])

# row 2 
d['Q'] = 1.0E-3  # volumetric pumping rate [L^3/T]
f.append([d['Q']])

# row 3
d['l'] = 0.0  # normalized depth to bottom of well screen from top of aquifer [L]
d['d'] = 1.0  # normalized "        "   top   "   "   "          "        "   [L]
f.append([d['l'],d['d']])

# row 4
d['rw'] = 0.01  # well casing radius at screen [L]
d['rc'] = 0.01  # well casing radius at water level [L]
f.append([d['rw'],d['rc']])

# row 5
d['gamma'] = 1.0  # dimensionless wellbore skin factor (1=no skin)
f.append([d['gamma']])

# row 6
d['Qtype'] = 1  # pumping well time behavior type
# if Qtype < 0, then pars is a list of times for piecwise-constant behavior
d['Qpars'] = [0.0, 1.0]  # list of time behavior parameters 
f.append([d['Qtype'],d['Qpars']])

# row 7
d['b'] = 20.0  # aquifer initial saturated thickness [L]
f.append([d['b']])

# row 8
d['Kr'] = 1.0E-3  # aquifer radial hydraulic conductivity [L/T]
d['kappa'] = 1.0  # ratio Kr/Kz
f.append([d['Kr'],d['kappa']])

# row 9
d['Ss'] = 1.0E-5  # aquifer specific storage [1/L]
d['Sy'] = 0.25    # dimensionless aquifer specific yield

# row 10
d['beta'] = d['b'] # Malama 2011 linearization parameter

# row 11: Mishra/Neuman 2010 model
d['ac'] = 0.4  # sorptive number for water capacity [1/L]
d['ak'] = 3.0  # sorptive number for conductivity [1/L]
d['psia'] = 5.6  # negative head for air-entry pressure [L]
d['psik'] = 5.8  # negative head for saturated conductivity [L]
d['L'] = 10.0  # unsaturated zone thickness [L]

# row 12: de Hoog, Knight & Stokes 
d['M'] = 20  
d['alpha'] = 1.0E-8
d['tol'] = 1.0E-9

# row 13: tanh/sinh quadrature 
d['tsk'] = 8  # 2^k-1 = number of abcissa
d['tsr'] = d['tsk'] - 2 # levels to do Richardson extrapolation on

# row 14: Gauss-Lobatto quadrature 
d['glsplit'] = [2,3]  # min/max of J0 zeros to split at
d['glnumz'] = 20 # number of zeros to integrate beyond split
d['glord'] = 16 # number of abcissa between each two J0 zeros

# row 15
d['tfname'] = 'timedata.dat'  # filename for time data
d['tdef'] = [0.25,]  # time to use if contour map calc

# row 16
d['sfname'] = 'spacedata.dat' # filename for space data
d['rdef'] = [0.25,]  # radial distance to use if timeseries calc

# row 17
d['obstop'] = 0.0 # relative top of observation well (or location of piezometer)
d['obsbot'] = 1.0 # bottom of observation well
d['obsord'] = 5 # abcissa in quadrature across well screen

# row 18
d['outfname'] = 'output.out'  # file generated by fortran code

#### related to time data file ####
# line 1
d['tcomp'] = True  # compute times (False -> read times from file)
d['ntfile'] = 100  # number of times to read from file

# line 2: logspace() parameters
d['minlogt'] = -4  
d['maxlogt'] = 10
d['ntcomp'] = 200

d['t'] = []

#### related to space data file ####
# line 1
d['rzcomp'] = True  # compute locations? (False -> read locs  from file)
d['nrfile'] = 100  # number of radial distances to read from file
# (z=0 is bottom of aquifer)
d['nzfile'] = 100  # number of vertical distances to read from file 

# line 2: linspace() parameters
d['minr'] = 0.025  
d['maxr'] = 30.0
d['nrcomp'] = 30

d['minz'] = 0.0  
d['maxz'] = 1.0
d['nzcomp'] = 12

d['r'] = []
d['z'] = []

