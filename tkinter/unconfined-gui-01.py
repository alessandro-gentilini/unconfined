#!/usr/bin/env python
import Tkinter as tk

# data for model (variables defined as defaults below)
d = {}

d['infname'] = 'input.dat' # input file read by fortran code

# row 1 
d['quiet'] = False  # echo verbosely to screen while running?
d['model'] = 1      # model to use (0-6)
d['dimless'] = True # dimensionless output?
d['tseries'] = True # timeseries (hydrograph)?  (false -> contour map)
d['piezo'] = True   # point piezometer? (false -> screened observation well)

# row 2 
d['Q'] = 1.0E-3  # volumetric pumping rate [L^3/T]

# row 3
d['l'] = 0.0  # depth to bottom of well screen from top of aquifer [L]
d['d'] = 1.0  # "        "   top   "   "   "          "        "   [L]

# row 4
d['rw'] = 0.01  # well casing radius at screen [L]
d['rc'] = 0.01  # well casing radius at water level [L]

# row 5
d['gamma'] = 1.0  # dimensionless wellbore skin factor (1=no skin)

# row 6
d['Qtype'] = 1  # pumping well time behavior type
# if Qtype < 0, then pars is a list of times for piecwise-constant behavior
d['Qpars'] = [0.0, 1.0]  # list of time behavior parameters 

# row 7
d['b'] = 20.0  # aquifer initial saturated thickness [L]

# row 8
d['Kr'] = 1.0E-3  # aquifer radial hydraulic conductivity [L/T]
d['kappa'] = 1.0  # ratio Kr/Kz

# row 9
d['Ss'] = 1.0E-5  # aquifer specific storage [1/L]
d['Sy'] = 0.25    # dimensionless aquifer specific yield

# row 10
d['beta'] = d['b'] # Malama 2011 linearization parameter

# row 11: Mishra/Neuman 2010 model
d['ac'] = 0.4  # sorptive number for water capacity [1/L]
d['ak'] = 3.0  # sorptive number for conductivity [1/L]
d['psia'] = 5.6  # negative head for air-entry pressure [L]
d['psik'] = 5.8  # negative head for saturated conductivity [L]
d['L'] = 10.0  # unsaturated zone thickness [L]

# row 12: de Hoog, Knight & Stokes 
d['M'] = 20  
d['alpha'] = 1.0E-8
d['tol'] = 1.0E-9

# row 13: tanh/sinh quadrature 
d['tsk'] = 8  # 2^k-1 = number of abcissa
d['tsr'] = d['tsk'] - 2 # levels to do Richardson extrapolation on

# row 14: Gauss-Lobatto quadrature 
d['glsplit'] = [2,3]  # min/max of J0 zeros to split at
d['glnumz'] = 20 # number of zeros to integrate beyond split
d['glord'] = 16 # number of abcissa between each two J0 zeros

# row 15
d['tfname'] = 'timedata.dat'  # filename for time data
d['t'] = [0.25,]  # time to use if contour map calc

# row 16
d['sfname'] = 'spacedata.dat' # filename for space data
d['r'] = [0.25,]  # radial distance to use if timeseries calc

# row 17
d['obstop'] = 0.0 # relative top of observation well (or location of piezometer)
d['obsbot'] = 1.0 # bottom of observation well
d['obsord'] = 5 # abcissa in quadrature across well screen

# row 18
d['outfname'] = 'output.out'  # file generated by fortran code

#### related to time data file ####
td = {}

# line 1
td['comp'] = True  # compute times (False -> read times from file)
td['nfile'] = 100  # number of times to read from file

# line 2: logspace() parameters
td['minlogt'] = -4  
td['maxlogt'] = 10
td['ntcomp'] = 200

td['t'] = []

#### related to space data file ####
sd = {}

# line 1
sd['comp'] = True  # compute locations? (False -> read locs  from file)
sd['nrfile'] = 100  # number of radial distances to read from file
# (z=0 is bottom of aquifer)
sd['nzfile'] = 100  # number of vertical distances to read from file 

# line 2: linspace() parameters
sd['minr'] = 0.025  
sd['maxr'] = 30.0
sd['nrcomp'] = 30

sd['minz'] = 0.0  
sd['maxz'] = 1.0
sd['nzcomp'] = 12

sd['r'] = []
sd['z'] = []


root = tk.Tk()

# left half of window
lframe = tk.Frame(root)
lframe.pack(side='left')


# right half of window
rframe = tk.Frame(root)
rframe.pack(side='left')

root.mainloop()

